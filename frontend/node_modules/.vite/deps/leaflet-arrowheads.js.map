{
  "version": 3,
  "sources": ["../../leaflet-geometryutil/src/leaflet.geometryutil.js", "../../leaflet-arrowheads/src/index.js", "../../leaflet-arrowheads/src/leaflet-arrowheads.js"],
  "sourcesContent": ["// Packaging/modules magic dance.\n(function (factory) {\n    var L;\n    if (typeof define === 'function' && define.amd) {\n        // AMD\n        define(['leaflet'], factory);\n    } else if (typeof module !== 'undefined') {\n        // Node/CommonJS\n        L = require('leaflet');\n        module.exports = factory(L);\n    } else {\n        // Browser globals\n        if (typeof window.L === 'undefined')\n            throw 'Leaflet must be loaded first';\n        factory(window.L);\n    }\n}(function (L) {\n\"use strict\";\n\nL.Polyline._flat = L.LineUtil.isFlat || L.Polyline._flat || function (latlngs) {\n    // true if it's a flat array of latlngs; false if nested\n    return !L.Util.isArray(latlngs[0]) || (typeof latlngs[0][0] !== 'object' && typeof latlngs[0][0] !== 'undefined');\n};\n\n/**\n * @fileOverview Leaflet Geometry utilities for distances and linear referencing.\n * @name L.GeometryUtil\n */\n\nL.GeometryUtil = L.extend(L.GeometryUtil || {}, {\n\n    /**\n        Shortcut function for planar distance between two {L.LatLng} at current zoom.\n\n        @tutorial distance-length\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlngA geographical point A\n        @param {L.LatLng} latlngB geographical point B\n        @returns {Number} planar distance\n     */\n    distance: function (map, latlngA, latlngB) {\n        return map.latLngToLayerPoint(latlngA).distanceTo(map.latLngToLayerPoint(latlngB));\n    },\n\n    /**\n        Shortcut function for planar distance between a {L.LatLng} and a segment (A-B).\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @returns {Number} planar distance\n    */\n    distanceSegment: function (map, latlng, latlngA, latlngB) {\n        var p = map.latLngToLayerPoint(latlng),\n           p1 = map.latLngToLayerPoint(latlngA),\n           p2 = map.latLngToLayerPoint(latlngB);\n        return L.LineUtil.pointToSegmentDistance(p, p1, p2);\n    },\n\n    /**\n        Shortcut function for converting distance to readable distance.\n        @param {Number} distance distance to be converted\n        @param {String} unit 'metric' or 'imperial'\n        @returns {String} in yard or miles\n    */\n    readableDistance: function (distance, unit) {\n        var isMetric = (unit !== 'imperial'),\n            distanceStr;\n        if (isMetric) {\n            // show metres when distance is < 1km, then show km\n            if (distance > 1000) {\n                distanceStr = (distance  / 1000).toFixed(2) + ' km';\n            }\n            else {\n                distanceStr = distance.toFixed(1) + ' m';\n            }\n        }\n        else {\n            distance *= 1.09361;\n            if (distance > 1760) {\n                distanceStr = (distance / 1760).toFixed(2) + ' miles';\n            }\n            else {\n                distanceStr = distance.toFixed(1) + ' yd';\n            }\n        }\n        return distanceStr;\n    },\n\n    /**\n        Returns true if the latlng belongs to segment A-B\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @param {?Number} [tolerance=0.2] tolerance to accept if latlng belongs really\n        @returns {boolean}\n     */\n    belongsSegment: function(latlng, latlngA, latlngB, tolerance) {\n        tolerance = tolerance === undefined ? 0.2 : tolerance;\n        var hypotenuse = latlngA.distanceTo(latlngB),\n            delta = latlngA.distanceTo(latlng) + latlng.distanceTo(latlngB) - hypotenuse;\n        return delta/hypotenuse < tolerance;\n    },\n\n    /**\n     * Returns total length of line\n     * @tutorial distance-length\n     *\n     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n     * @returns {Number} Total length (pixels for Point, meters for LatLng)\n     */\n    length: function (coords) {\n        var accumulated = L.GeometryUtil.accumulatedLengths(coords);\n        return accumulated.length > 0 ? accumulated[accumulated.length-1] : 0;\n    },\n\n    /**\n     * Returns a list of accumulated length along a line.\n     * @param {L.Polyline|Array<L.Point>|Array<L.LatLng>} coords Set of coordinates\n     * @returns {Array<Number>} Array of accumulated lengths (pixels for Point, meters for LatLng)\n     */\n    accumulatedLengths: function (coords) {\n        if (typeof coords.getLatLngs == 'function') {\n            coords = coords.getLatLngs();\n        }\n        if (coords.length === 0)\n            return [];\n        var total = 0,\n            lengths = [0];\n        for (var i = 0, n = coords.length - 1; i< n; i++) {\n            total += coords[i].distanceTo(coords[i+1]);\n            lengths.push(total);\n        }\n        return lengths;\n    },\n\n    /**\n        Returns the closest point of a {L.LatLng} on the segment (A-B)\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.LatLng} latlng - The position to search\n        @param {L.LatLng} latlngA geographical point A of the segment\n        @param {L.LatLng} latlngB geographical point B of the segment\n        @returns {L.LatLng} Closest geographical point\n    */\n    closestOnSegment: function (map, latlng, latlngA, latlngB) {\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity)\n            maxzoom = map.getZoom();\n        var p = map.project(latlng, maxzoom),\n           p1 = map.project(latlngA, maxzoom),\n           p2 = map.project(latlngB, maxzoom),\n           closest = L.LineUtil.closestPointOnSegment(p, p1, p2);\n        return map.unproject(closest, maxzoom);\n    },\n\n    /**\n    Returns the closest point of a {L.LatLng} on a {L.Circle}\n\n    @tutorial closest\n\n    @param {L.LatLng} latlng - The position to search\n    @param {L.Circle} circle - A Circle defined by a center and a radius\n    @returns {L.LatLng} Closest geographical point on the circle circumference\n    */\n    closestOnCircle: function (circle, latLng) {\n        const center = circle.getLatLng();\n        const circleRadius = circle.getRadius();\n        const radius = typeof circleRadius === 'number' ? circleRadius : circleRadius.radius;\n        const x = latLng.lng;\n        const y = latLng.lat;\n        const cx = center.lng;\n        const cy = center.lat;\n        // dx and dy is the vector from the circle's center to latLng\n        const dx = x - cx;\n        const dy = y - cy;\n\n        // distance between the point and the circle's center\n        const distance = Math.sqrt(dx * dx + dy * dy)\n\n        // Calculate the closest point on the circle by adding the normalized vector to the center\n        const tx = cx + (dx / distance) * radius;\n        const ty = cy + (dy / distance) * radius;\n\n        return new L.LatLng(ty, tx);\n    },\n    \n\n    /**\n        Returns the closest latlng on layer.\n\n        Accept nested arrays\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.LatLng>|Array<Array<L.LatLng>>|L.PolyLine|L.Polygon} layer - Layer that contains the result\n        @param {L.LatLng} latlng - The position to search\n        @param {?boolean} [vertices=false] - Whether to restrict to path vertices.\n        @returns {L.LatLng} Closest geographical point or null if layer param is incorrect\n    */\n    closest: function (map, layer, latlng, vertices) {\n\n        var latlngs,\n            mindist = Infinity,\n            result = null,\n            i, n, distance, subResult;\n\n        if (layer instanceof Array) {\n            // if layer is Array<Array<T>>\n            if (layer[0] instanceof Array && typeof layer[0][0] !== 'number') {\n                // if we have nested arrays, we calc the closest for each array\n                // recursive\n                for (i = 0; i < layer.length; i++) {\n                    subResult = L.GeometryUtil.closest(map, layer[i], latlng, vertices);\n                    if (subResult && subResult.distance < mindist) {\n                        mindist = subResult.distance;\n                        result = subResult;\n                    }\n                }\n                return result;\n            } else if (layer[0] instanceof L.LatLng\n                        || typeof layer[0][0] === 'number'\n                        || typeof layer[0].lat === 'number') { // we could have a latlng as [x,y] with x & y numbers or {lat, lng}\n                layer = L.polyline(layer);\n            } else {\n                return result;\n            }\n        }\n\n        // if we don't have here a Polyline, that means layer is incorrect\n        // see https://github.com/makinacorpus/Leaflet.GeometryUtil/issues/23\n        if (! ( layer instanceof L.Polyline ) )\n            return result;\n\n        // deep copy of latlngs\n        latlngs = JSON.parse(JSON.stringify(layer.getLatLngs().slice(0)));\n\n        // add the last segment for L.Polygon\n        if (layer instanceof L.Polygon) {\n            // add the last segment for each child that is a nested array\n            var addLastSegment = function(latlngs) {\n                if (L.Polyline._flat(latlngs)) {\n                    latlngs.push(latlngs[0]);\n                } else {\n                    for (var i = 0; i < latlngs.length; i++) {\n                        addLastSegment(latlngs[i]);\n                    }\n                }\n            };\n            addLastSegment(latlngs);\n        }\n\n        // we have a multi polygon / multi polyline / polygon with holes\n        // use recursive to explore and return the good result\n        if ( ! L.Polyline._flat(latlngs) ) {\n            for (i = 0; i < latlngs.length; i++) {\n                // if we are at the lower level, and if we have a L.Polygon, we add the last segment\n                subResult = L.GeometryUtil.closest(map, latlngs[i], latlng, vertices);\n                if (subResult.distance < mindist) {\n                    mindist = subResult.distance;\n                    result = subResult;\n                }\n            }\n            return result;\n\n        } else {\n\n            // Lookup vertices\n            if (vertices) {\n                for(i = 0, n = latlngs.length; i < n; i++) {\n                    var ll = latlngs[i];\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                    if (distance < mindist) {\n                        mindist = distance;\n                        result = ll;\n                        result.distance = distance;\n                    }\n                }\n                return result;\n            }\n\n            // Keep the closest point of all segments\n            for (i = 0, n = latlngs.length; i < n-1; i++) {\n                var latlngA = latlngs[i],\n                    latlngB = latlngs[i+1];\n                distance = L.GeometryUtil.distanceSegment(map, latlng, latlngA, latlngB);\n                if (distance <= mindist) {\n                    mindist = distance;\n                    result = L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n                    result.distance = distance;\n                }\n            }\n            return result;\n        }\n\n    },\n\n    /**\n        Returns the closest layer to latlng among a list of layers.\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.ILayer>} layers Set of layers\n        @param {L.LatLng} latlng - The position to search\n        @returns {object} ``{layer, latlng, distance}`` or ``null`` if list is empty;\n    */\n    closestLayer: function (map, layers, latlng) {\n        var mindist = Infinity,\n            result = null,\n            ll = null,\n            distance = Infinity;\n\n        for (var i = 0, n = layers.length; i < n; i++) {\n            var layer = layers[i];\n            if (layer instanceof L.LayerGroup) {\n                // recursive\n                var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n                if (subResult.distance < mindist) {\n                    mindist = subResult.distance;\n                    result = subResult;\n                }\n            } else {\n                if (layer instanceof L.Circle){\n                    ll = this.closestOnCircle(layer, latlng);\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                } else\n                // Single dimension, snap on points, else snap on closest\n                if (typeof layer.getLatLng == 'function') {\n                    ll = layer.getLatLng();\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                }\n                else {\n                    ll = L.GeometryUtil.closest(map, layer, latlng);\n                    if (ll) distance = ll.distance;  // Can return null if layer has no points.\n                }\n                if (distance < mindist) {\n                    mindist = distance;\n                    result = {layer: layer, latlng: ll, distance: distance};\n                }\n            }\n        }\n        return result;\n    },\n\n    /**\n        Returns the n closest layers to latlng among a list of input layers.\n\n        @param {L.Map} map - Leaflet map to be used for this method\n        @param {Array<L.ILayer>} layers - Set of layers\n        @param {L.LatLng} latlng - The position to search\n        @param {?Number} [n=layers.length] - the expected number of output layers.\n        @returns {Array<object>} an array of objects ``{layer, latlng, distance}`` or ``null`` if the input is invalid (empty list or negative n)\n    */\n    nClosestLayers: function (map, layers, latlng, n) {\n        n = typeof n === 'number' ? n : layers.length;\n\n        if (n < 1 || layers.length < 1) {\n            return null;\n        }\n\n        var results = [];\n        var distance, ll;\n\n        for (var i = 0, m = layers.length; i < m; i++) {\n            var layer = layers[i];\n            if (layer instanceof L.LayerGroup) {\n                // recursive\n                var subResult = L.GeometryUtil.closestLayer(map, layer.getLayers(), latlng);\n                results.push(subResult);\n            } else {\n                if (layer instanceof L.Circle){\n                    ll = this.closestOnCircle(layer, latlng);\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                } else\n                // Single dimension, snap on points, else snap on closest\n                if (typeof layer.getLatLng == 'function') {\n                    ll = layer.getLatLng();\n                    distance = L.GeometryUtil.distance(map, latlng, ll);\n                }\n                else {\n                    ll = L.GeometryUtil.closest(map, layer, latlng);\n                    if (ll) distance = ll.distance;  // Can return null if layer has no points.\n                }\n                results.push({layer: layer, latlng: ll, distance: distance});\n            }\n        }\n\n        results.sort(function(a, b) {\n            return a.distance - b.distance;\n        });\n\n        if (results.length > n) {\n            return results.slice(0, n);\n        } else  {\n            return results;\n        }\n    },\n\n    /**\n     * Returns all layers within a radius of the given position, in an ascending order of distance.\n       @param {L.Map} map Leaflet map to be used for this method\n       @param {Array<ILayer>} layers - A list of layers.\n       @param {L.LatLng} latlng - The position to search\n       @param {?Number} [radius=Infinity] - Search radius in pixels\n       @return {object[]} an array of objects including layer within the radius, closest latlng, and distance\n     */\n    layersWithin: function(map, layers, latlng, radius) {\n      radius = typeof radius == 'number' ? radius : Infinity;\n\n      var results = [];\n      var ll = null;\n      var distance = 0;\n\n      for (var i = 0, n = layers.length; i < n; i++) {\n        var layer = layers[i];\n\n        if (typeof layer.getLatLng == 'function') {\n            ll = layer.getLatLng();\n            distance = L.GeometryUtil.distance(map, latlng, ll);\n        }\n        else {\n            ll = L.GeometryUtil.closest(map, layer, latlng);\n            if (ll) distance = ll.distance;  // Can return null if layer has no points.\n        }\n\n        if (ll && distance < radius) {\n            results.push({layer: layer, latlng: ll, distance: distance});\n        }\n      }\n\n      var sortedResults = results.sort(function(a, b) {\n          return a.distance - b.distance;\n      });\n\n      return sortedResults;\n    },\n\n    /**\n        Returns the closest position from specified {LatLng} among specified layers,\n        with a maximum tolerance in pixels, providing snapping behaviour.\n\n        @tutorial closest\n\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<ILayer>} layers - A list of layers to snap on.\n        @param {L.LatLng} latlng - The position to snap\n        @param {?Number} [tolerance=Infinity] - Maximum number of pixels.\n        @param {?boolean} [withVertices=true] - Snap to layers vertices or segment points (not only vertex)\n        @returns {object} with snapped {LatLng} and snapped {Layer} or null if tolerance exceeded.\n    */\n    closestLayerSnap: function (map, layers, latlng, tolerance, withVertices) {\n        tolerance = typeof tolerance == 'number' ? tolerance : Infinity;\n        withVertices = typeof withVertices == 'boolean' ? withVertices : true;\n\n        var result = L.GeometryUtil.closestLayer(map, layers, latlng);\n        if (!result || result.distance > tolerance)\n            return null;\n\n        // If snapped layer is linear, try to snap on vertices (extremities and middle points)\n        if (withVertices && typeof result.layer.getLatLngs == 'function') {\n            var closest = L.GeometryUtil.closest(map, result.layer, result.latlng, true);\n            if (closest.distance < tolerance) {\n                result.latlng = closest;\n                result.distance = L.GeometryUtil.distance(map, closest, latlng);\n            }\n        }\n        return result;\n    },\n\n    /**\n        Returns the Point located on a segment at the specified ratio of the segment length.\n        @param {L.Point} pA coordinates of point A\n        @param {L.Point} pB coordinates of point B\n        @param {Number} the length ratio, expressed as a decimal between 0 and 1, inclusive.\n        @returns {L.Point} the interpolated point.\n    */\n    interpolateOnPointSegment: function (pA, pB, ratio) {\n        return L.point(\n            (pA.x * (1 - ratio)) + (ratio * pB.x),\n            (pA.y * (1 - ratio)) + (ratio * pB.y)\n        );\n    },\n\n    /**\n        Returns the coordinate of the point located on a line at the specified ratio of the line length.\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {Array<L.LatLng>|L.PolyLine} latlngs Set of geographical points\n        @param {Number} ratio the length ratio, expressed as a decimal between 0 and 1, inclusive\n        @returns {Object} an object with latLng ({LatLng}) and predecessor ({Number}), the index of the preceding vertex in the Polyline\n        (-1 if the interpolated point is the first vertex)\n    */\n    interpolateOnLine: function (map, latLngs, ratio) {\n        latLngs = (latLngs instanceof L.Polyline) ? latLngs.getLatLngs() : latLngs;\n        var n = latLngs.length;\n        if (n < 2) {\n            return null;\n        }\n\n        // ensure the ratio is between 0 and 1;\n        ratio = Math.max(Math.min(ratio, 1), 0);\n\n        if (ratio === 0) {\n            return {\n                latLng: latLngs[0] instanceof L.LatLng ? latLngs[0] : L.latLng(latLngs[0]),\n                predecessor: -1\n            };\n        }\n        if (ratio == 1) {\n            return {\n                latLng: latLngs[latLngs.length -1] instanceof L.LatLng ? latLngs[latLngs.length -1] : L.latLng(latLngs[latLngs.length -1]),\n                predecessor: latLngs.length - 2\n            };\n        }\n\n        // project the LatLngs as Points,\n        // and compute total planar length of the line at max precision\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity)\n            maxzoom = map.getZoom();\n        var pts = [];\n        var lineLength = 0;\n        for(var i = 0; i < n; i++) {\n            pts[i] = map.project(latLngs[i], maxzoom);\n            if(i > 0)\n              lineLength += pts[i-1].distanceTo(pts[i]);\n        }\n\n        var ratioDist = lineLength * ratio;\n\n\t\t// follow the line segments [ab], adding lengths,\n        // until we find the segment where the points should lie on\n\t\tvar cumulativeDistanceToA = 0, cumulativeDistanceToB = 0;\n\t\tfor (var i = 0; cumulativeDistanceToB < ratioDist; i++) {\n\t\t\tvar pointA = pts[i], pointB = pts[i+1];\n\n\t\t\tcumulativeDistanceToA = cumulativeDistanceToB;\n\t\t\tcumulativeDistanceToB += pointA.distanceTo(pointB);\n\t\t}\n\t\t\n\t\tif (pointA == undefined && pointB == undefined) { // Happens when line has no length\n\t\t\tvar pointA = pts[0], pointB = pts[1], i = 1;\n\t\t}\n\n\t\t// compute the ratio relative to the segment [ab]\n\t\tvar segmentRatio = ((cumulativeDistanceToB - cumulativeDistanceToA) !== 0) ? ((ratioDist - cumulativeDistanceToA) / (cumulativeDistanceToB - cumulativeDistanceToA)) : 0;\n\t\tvar interpolatedPoint = L.GeometryUtil.interpolateOnPointSegment(pointA, pointB, segmentRatio);\n\t\treturn {\n\t\t\tlatLng: map.unproject(interpolatedPoint, maxzoom),\n\t\t\tpredecessor: i-1\n\t\t};\n    },\n\n    /**\n        Returns a float between 0 and 1 representing the location of the\n        closest point on polyline to the given latlng, as a fraction of total line length.\n        (opposite of L.GeometryUtil.interpolateOnLine())\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.PolyLine} polyline Polyline on which the latlng will be search\n        @param {L.LatLng} latlng The position to search\n        @returns {Number} Float between 0 and 1\n    */\n    locateOnLine: function (map, polyline, latlng) {\n        var latlngs = polyline.getLatLngs();\n        if (latlng.equals(latlngs[0]))\n            return 0.0;\n        if (latlng.equals(latlngs[latlngs.length-1]))\n            return 1.0;\n\n        var point = L.GeometryUtil.closest(map, polyline, latlng, false),\n            lengths = L.GeometryUtil.accumulatedLengths(latlngs),\n            total_length = lengths[lengths.length-1],\n            portion = 0,\n            found = false;\n        for (var i=0, n = latlngs.length-1; i < n; i++) {\n            var l1 = latlngs[i],\n                l2 = latlngs[i+1];\n            portion = lengths[i];\n            if (L.GeometryUtil.belongsSegment(point, l1, l2, 0.001)) {\n                portion += l1.distanceTo(point);\n                found = true;\n                break;\n            }\n        }\n        if (!found) {\n            throw \"Could not interpolate \" + latlng.toString() + \" within \" + polyline.toString();\n        }\n        return portion / total_length;\n    },\n\n    /**\n        Returns a clone with reversed coordinates.\n        @param {L.PolyLine} polyline polyline to reverse\n        @returns {L.PolyLine} polyline reversed\n    */\n    reverse: function (polyline) {\n        return L.polyline(polyline.getLatLngs().slice(0).reverse());\n    },\n\n    /**\n        Returns a sub-part of the polyline, from start to end.\n        If start is superior to end, returns extraction from inverted line.\n        @param {L.Map} map Leaflet map to be used for this method\n        @param {L.PolyLine} polyline Polyline on which will be extracted the sub-part\n        @param {Number} start ratio, expressed as a decimal between 0 and 1, inclusive\n        @param {Number} end ratio, expressed as a decimal between 0 and 1, inclusive\n        @returns {Array<L.LatLng>} new polyline\n     */\n    extract: function (map, polyline, start, end) {\n        if (start > end) {\n            return L.GeometryUtil.extract(map, L.GeometryUtil.reverse(polyline), 1.0-start, 1.0-end);\n        }\n\n        // Bound start and end to [0-1]\n        start = Math.max(Math.min(start, 1), 0);\n        end = Math.max(Math.min(end, 1), 0);\n\n        var latlngs = polyline.getLatLngs(),\n            startpoint = L.GeometryUtil.interpolateOnLine(map, polyline, start),\n            endpoint = L.GeometryUtil.interpolateOnLine(map, polyline, end);\n        // Return single point if start == end\n        if (start == end) {\n            var point = L.GeometryUtil.interpolateOnLine(map, polyline, end);\n            return [point.latLng];\n        }\n        // Array.slice() works indexes at 0\n        if (startpoint.predecessor == -1)\n            startpoint.predecessor = 0;\n        if (endpoint.predecessor == -1)\n            endpoint.predecessor = 0;\n        var result = latlngs.slice(startpoint.predecessor+1, endpoint.predecessor+1);\n        result.unshift(startpoint.latLng);\n        result.push(endpoint.latLng);\n        return result;\n    },\n\n    /**\n        Returns true if first polyline ends where other second starts.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    isBefore: function (polyline, other) {\n        if (!other) return false;\n        var lla = polyline.getLatLngs(),\n            llb = other.getLatLngs();\n        return (lla[lla.length-1]).equals(llb[0]);\n    },\n\n    /**\n        Returns true if first polyline starts where second ends.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    isAfter: function (polyline, other) {\n        if (!other) return false;\n        var lla = polyline.getLatLngs(),\n            llb = other.getLatLngs();\n        return (lla[0]).equals(llb[llb.length-1]);\n    },\n\n    /**\n        Returns true if first polyline starts where second ends or start.\n        @param {L.PolyLine} polyline First polyline\n        @param {L.PolyLine} other Second polyline\n        @returns {bool}\n    */\n    startsAtExtremity: function (polyline, other) {\n        if (!other) return false;\n        var lla = polyline.getLatLngs(),\n            llb = other.getLatLngs(),\n            start = lla[0];\n        return start.equals(llb[0]) || start.equals(llb[llb.length-1]);\n    },\n\n    /**\n        Returns horizontal angle in degres between two points.\n        @param {L.Point} a Coordinates of point A\n        @param {L.Point} b Coordinates of point B\n        @returns {Number} horizontal angle\n     */\n    computeAngle: function(a, b) {\n        return (Math.atan2(b.y - a.y, b.x - a.x) * 180 / Math.PI);\n    },\n\n    /**\n       Returns slope (Ax+B) between two points.\n        @param {L.Point} a Coordinates of point A\n        @param {L.Point} b Coordinates of point B\n        @returns {Object} with ``a`` and ``b`` properties.\n     */\n    computeSlope: function(a, b) {\n        var s = (b.y - a.y) / (b.x - a.x),\n            o = a.y - (s * a.x);\n        return {'a': s, 'b': o};\n    },\n\n    /**\n       Returns LatLng of rotated point around specified LatLng center.\n        @param {L.LatLng} latlngPoint: point to rotate\n        @param {double} angleDeg: angle to rotate in degrees\n        @param {L.LatLng} latlngCenter: center of rotation\n        @returns {L.LatLng} rotated point\n     */\n    rotatePoint: function(map, latlngPoint, angleDeg, latlngCenter) {\n        var maxzoom = map.getMaxZoom();\n        if (maxzoom === Infinity)\n            maxzoom = map.getZoom();\n        var angleRad = angleDeg*Math.PI/180,\n            pPoint = map.project(latlngPoint, maxzoom),\n            pCenter = map.project(latlngCenter, maxzoom),\n            x2 = Math.cos(angleRad)*(pPoint.x-pCenter.x) - Math.sin(angleRad)*(pPoint.y-pCenter.y) + pCenter.x,\n            y2 = Math.sin(angleRad)*(pPoint.x-pCenter.x) + Math.cos(angleRad)*(pPoint.y-pCenter.y) + pCenter.y;\n        return map.unproject(new L.Point(x2,y2), maxzoom);\n    },\n\n    /**\n       Returns the bearing in degrees clockwise from north (0 degrees)\n       from the first L.LatLng to the second, at the first LatLng\n       @param {L.LatLng} latlng1: origin point of the bearing\n       @param {L.LatLng} latlng2: destination point of the bearing\n       @returns {float} degrees clockwise from north.\n    */\n    bearing: function(latlng1, latlng2) {\n        var rad = Math.PI / 180,\n            lat1 = latlng1.lat * rad,\n            lat2 = latlng2.lat * rad,\n            lon1 = latlng1.lng * rad,\n            lon2 = latlng2.lng * rad,\n            y = Math.sin(lon2 - lon1) * Math.cos(lat2),\n            x = Math.cos(lat1) * Math.sin(lat2) -\n                Math.sin(lat1) * Math.cos(lat2) * Math.cos(lon2 - lon1);\n\n        var bearing = ((Math.atan2(y, x) * 180 / Math.PI) + 360) % 360;\n        return bearing >= 180 ? bearing-360 : bearing;\n    },\n\n    /**\n       Returns the point that is a distance and heading away from\n       the given origin point.\n       @param {L.LatLng} latlng: origin point\n       @param {float} heading: heading in degrees, clockwise from 0 degrees north.\n       @param {float} distance: distance in meters\n       @returns {L.latLng} the destination point.\n       Many thanks to Chris Veness at http://www.movable-type.co.uk/scripts/latlong.html\n       for a great reference and examples.\n    */\n    destination: function(latlng, heading, distance) {\n        heading = (heading + 360) % 360;\n        var rad = Math.PI / 180,\n            radInv = 180 / Math.PI,\n            R = L.CRS.Earth.R, // approximation of Earth's radius\n            lon1 = latlng.lng * rad,\n            lat1 = latlng.lat * rad,\n            rheading = heading * rad,\n            sinLat1 = Math.sin(lat1),\n            cosLat1 = Math.cos(lat1),\n            cosDistR = Math.cos(distance / R),\n            sinDistR = Math.sin(distance / R),\n            lat2 = Math.asin(sinLat1 * cosDistR + cosLat1 *\n                sinDistR * Math.cos(rheading)),\n            lon2 = lon1 + Math.atan2(Math.sin(rheading) * sinDistR *\n                cosLat1, cosDistR - sinLat1 * Math.sin(lat2));\n        lon2 = lon2 * radInv;\n        lon2 = lon2 > 180 ? lon2 - 360 : lon2 < -180 ? lon2 + 360 : lon2;\n        return L.latLng([lat2 * radInv, lon2]);\n    },\n\n    /**\n       Returns the the angle of the given segment and the Equator in degrees,\n       clockwise from 0 degrees north.\n       @param {L.Map} map: Leaflet map to be used for this method\n       @param {L.LatLng} latlngA: geographical point A of the segment\n       @param {L.LatLng} latlngB: geographical point B of the segment\n       @returns {Float} the angle in degrees.\n    */\n    angle: function(map, latlngA, latlngB) {\n      var pointA = map.latLngToContainerPoint(latlngA),\n          pointB = map.latLngToContainerPoint(latlngB),\n          angleDeg = Math.atan2(pointB.y - pointA.y, pointB.x - pointA.x) * 180 / Math.PI + 90;\n      angleDeg += angleDeg < 0 ? 360 : 0;\n      return angleDeg;\n    },\n\n    /**\n       Returns a point snaps on the segment and heading away from the given origin point a distance.\n       @param {L.Map} map: Leaflet map to be used for this method\n       @param {L.LatLng} latlngA: geographical point A of the segment\n       @param {L.LatLng} latlngB: geographical point B of the segment\n       @param {float} distance: distance in meters\n       @returns {L.latLng} the destination point.\n    */\n    destinationOnSegment: function(map, latlngA, latlngB, distance) {\n      var angleDeg = L.GeometryUtil.angle(map, latlngA, latlngB),\n          latlng = L.GeometryUtil.destination(latlngA, angleDeg, distance);\n      return L.GeometryUtil.closestOnSegment(map, latlng, latlngA, latlngB);\n    },\n});\n\nreturn L.GeometryUtil;\n\n}));\n", "import 'leaflet-geometryutil'\nimport './leaflet-arrowheads.js'", "function modulus(i, n) {\n\treturn ((i % n) + n) % n;\n}\n\nfunction definedProps(obj) {\n\treturn Object.fromEntries(\n\t\tObject.entries(obj).filter(([k, v]) => v !== undefined)\n\t);\n}\n\n/**\n * Whether or not a string is in the format '<number>m'\n * @param {string} value\n * @returns Boolean\n */\nfunction isInMeters(value) {\n\treturn (\n\t\tvalue\n\t\t\t.toString()\n\t\t\t.trim()\n\t\t\t.slice(value.toString().length - 1, value.toString().length) === 'm'\n\t);\n}\n\n/**\n * Whether or not a string is in the format '<number>%'\n * @param {string} value\n * @returns Boolean\n */\nfunction isInPercent(value) {\n\treturn (\n\t\tvalue\n\t\t\t.toString()\n\t\t\t.trim()\n\t\t\t.slice(value.toString().length - 1, value.toString().length) === '%'\n\t);\n}\n\n/**\n * Whether or not a string is in the format '<number>px'\n * @param {string} value\n * @returns Boolean\n */\nfunction isInPixels(value) {\n\treturn (\n\t\tvalue\n\t\t\t.toString()\n\t\t\t.trim()\n\t\t\t.slice(value.toString().length - 2, value.toString().length) === 'px'\n\t);\n}\n\nfunction pixelsToMeters(pixels, map) {\n\tlet refPoint1 = map.getCenter();\n\tlet xy1 = map.latLngToLayerPoint(refPoint1);\n\tlet xy2 = {\n\t\tx: xy1.x + Number(pixels),\n\t\ty: xy1.y,\n\t};\n\tlet refPoint2 = map.layerPointToLatLng(xy2);\n\tlet derivedMeters = map.distance(refPoint1, refPoint2);\n\treturn derivedMeters;\n}\n\nL.Polyline.include({\n\t/**\n\t * Adds arrowheads to an L.polyline\n\t * @param {object} options The options for the arrowhead.  See documentation for details\n\t * @returns The L.polyline instance that they arrowheads are attached to\n\t */\n\tarrowheads: function (options = {}) {\n\t\t// Merge user input options with default options:\n\t\tconst defaults = {\n\t\t\tyawn: 60,\n\t\t\tsize: '15%',\n\t\t\tfrequency: 'allvertices',\n\t\t\tproportionalToTotal: false,\n\t\t};\n\n\t\tthis.options.noClip = true;\n\n\t\tlet actualOptions = Object.assign({}, defaults, options);\n\t\tthis._arrowheadOptions = actualOptions;\n\n\t\tthis._hatsApplied = true;\n\t\treturn this;\n\t},\n\n\tbuildVectorHats: function (options) {\n\t\t// Reset variables from previous this._update()\n\t\tif (this._arrowheads) {\n\t\t\tthis._arrowheads.remove();\n\t\t}\n\n\t\tif (this._ghosts) {\n\t\t\tthis._ghosts.remove();\n\t\t}\n\n\t\t//  -------------------------------------------------------- //\n\t\t//  ------------  FILTER THE OPTIONS ----------------------- //\n\t\t/*\n\t\t * The next 3 lines folds the options of the parent polyline into the default options for all polylines\n\t\t * The options for the arrowhead are then folded in as well\n\t\t * All options defined in parent polyline will be inherited by the arrowhead, unless otherwise specified in the arrowhead(options) call\n\t\t */\n\n\t\tlet defaultOptionsOfParent = Object.getPrototypeOf(\n\t\t\tObject.getPrototypeOf(this.options)\n\t\t);\n\n\t\t// merge default options of parent polyline (this.options's prototype's prototype) with options passed to parent polyline (this.options).\n\t\tlet parentOptions = Object.assign({}, defaultOptionsOfParent, this.options);\n\n\t\t// now merge in the options the user has put in the arrowhead call\n\t\tlet hatOptions = Object.assign({}, parentOptions, options);\n\n\t\t// ...with a few exceptions:\n\t\thatOptions.smoothFactor = 1;\n\t\thatOptions.fillOpacity = 1;\n\t\thatOptions.fill = options.fill ? true : false;\n\t\thatOptions.interactive = false;\n\n\t\t//  ------------  FILTER THE OPTIONS END -------------------- //\n\t\t//  --------------------------------------------------------- //\n\n\t\t//  --------------------------------------------------------- //\n\t\t//  ------ LOOP THROUGH EACH POLYLINE SEGMENT --------------- //\n\t\t//  ------ TO CALCULATE HAT SIZES AND CAPTURE IN ARRAY ------ //\n\n\t\tlet size = options.size.toString(); // stringify if its a number\n\t\tlet allhats = []; // empty array to receive hat polylines\n\t\tconst { frequency, offsets } = options;\n\n\t\tif (offsets?.start || offsets?.end) {\n\t\t\tthis._buildGhosts({ start: offsets.start, end: offsets.end });\n\t\t}\n\n\t\tconst lineToTrace = this._ghosts || this;\n\n\t\tlineToTrace._parts.forEach((peice, index) => {\n\t\t\t// Immutable variables for each peice\n\t\t\tconst latlngs = peice.map((point) => this._map.layerPointToLatLng(point));\n\n\t\t\tconst totalLength = (() => {\n\t\t\t\tlet total = 0;\n\t\t\t\tfor (var i = 0; i < peice.length - 1; i++) {\n\t\t\t\t\ttotal += this._map.distance(latlngs[i], latlngs[i + 1]);\n\t\t\t\t}\n\t\t\t\treturn total;\n\t\t\t})();\n\n\t\t\t// TBD by options if tree below\n\t\t\tlet derivedLatLngs;\n\t\t\tlet derivedBearings;\n\t\t\tlet spacing;\n\t\t\tlet noOfPoints;\n\n\t\t\t//  Determining latlng and bearing arrays based on frequency choice:\n\t\t\tif (!isNaN(frequency)) {\n\t\t\t\tspacing = 1 / frequency;\n\t\t\t\tnoOfPoints = frequency;\n\t\t\t} else if (isInPercent(frequency)) {\n\t\t\t\tconsole.error(\n\t\t\t\t\t'Error: arrowhead frequency option cannot be given in percent.  Try another unit.'\n\t\t\t\t);\n\t\t\t} else if (isInMeters(frequency)) {\n\t\t\t\tspacing = frequency.slice(0, frequency.length - 1) / totalLength;\n\t\t\t\tnoOfPoints = 1 / spacing;\n\t\t\t\t// round things out for more even spacing:\n\t\t\t\tnoOfPoints = Math.floor(noOfPoints);\n\t\t\t\tspacing = 1 / noOfPoints;\n\t\t\t} else if (isInPixels(frequency)) {\n\t\t\t\tspacing = (() => {\n\t\t\t\t\tlet chosenFrequency = frequency.slice(0, frequency.length - 2);\n\t\t\t\t\tlet derivedMeters = pixelsToMeters(chosenFrequency, this._map);\n\t\t\t\t\treturn derivedMeters / totalLength;\n\t\t\t\t})();\n\n\t\t\t\tnoOfPoints = 1 / spacing;\n\n\t\t\t\t// round things out for more even spacing:\n\t\t\t\tnoOfPoints = Math.floor(noOfPoints);\n\t\t\t\tspacing = 1 / noOfPoints;\n\t\t\t}\n\n\t\t\tif (options.frequency === 'allvertices') {\n\t\t\t\tderivedBearings = (() => {\n\t\t\t\t\tlet bearings = [];\n\t\t\t\t\tfor (var i = 1; i < latlngs.length; i++) {\n\t\t\t\t\t\tlet bearing =\n\t\t\t\t\t\t\tL.GeometryUtil.angle(\n\t\t\t\t\t\t\t\tthis._map,\n\t\t\t\t\t\t\t\tlatlngs[modulus(i - 1, latlngs.length)],\n\t\t\t\t\t\t\t\tlatlngs[i]\n\t\t\t\t\t\t\t) + 180;\n\t\t\t\t\t\tbearings.push(bearing);\n\t\t\t\t\t}\n\t\t\t\t\treturn bearings;\n\t\t\t\t})();\n\n\t\t\t\tderivedLatLngs = latlngs;\n\t\t\t\tderivedLatLngs.shift();\n\t\t\t} else if (options.frequency === 'endonly' && latlngs.length >= 2) {\n\t\t\t\tderivedLatLngs = [latlngs[latlngs.length - 1]];\n\n\t\t\t\tderivedBearings = [\n\t\t\t\t\tL.GeometryUtil.angle(\n\t\t\t\t\t\tthis._map,\n\t\t\t\t\t\tlatlngs[latlngs.length - 2],\n\t\t\t\t\t\tlatlngs[latlngs.length - 1]\n\t\t\t\t\t) + 180,\n\t\t\t\t];\n\t\t\t} else {\n\t\t\t\tderivedLatLngs = [];\n\t\t\t\tlet interpolatedPoints = [];\n\t\t\t\tfor (var i = 0; i < noOfPoints; i++) {\n\t\t\t\t\tlet interpolatedPoint = L.GeometryUtil.interpolateOnLine(\n\t\t\t\t\t\tthis._map,\n\t\t\t\t\t\tlatlngs,\n\t\t\t\t\t\tspacing * (i + 1)\n\t\t\t\t\t);\n\n\t\t\t\t\tif (interpolatedPoint) {\n\t\t\t\t\t\tinterpolatedPoints.push(interpolatedPoint);\n\t\t\t\t\t\tderivedLatLngs.push(interpolatedPoint.latLng);\n\t\t\t\t\t}\n\t\t\t\t}\n\n\t\t\t\tderivedBearings = (() => {\n\t\t\t\t\tlet bearings = [];\n\n\t\t\t\t\tfor (var i = 0; i < interpolatedPoints.length; i++) {\n\t\t\t\t\t\tlet bearing = L.GeometryUtil.angle(\n\t\t\t\t\t\t\tthis._map,\n\t\t\t\t\t\t\tlatlngs[interpolatedPoints[i].predecessor + 1],\n\t\t\t\t\t\t\tlatlngs[interpolatedPoints[i].predecessor]\n\t\t\t\t\t\t);\n\t\t\t\t\t\tbearings.push(bearing);\n\t\t\t\t\t}\n\t\t\t\t\treturn bearings;\n\t\t\t\t})();\n\t\t\t}\n\n\t\t\tlet hats = [];\n\n\t\t\t// Function to build hats based on index and a given hatsize in meters\n\t\t\tconst pushHats = (size, localHatOptions = {}) => {\n\t\t\t\tlet yawn = localHatOptions.yawn ?? options.yawn;\n\n\t\t\t\tlet leftWingPoint = L.GeometryUtil.destination(\n\t\t\t\t\tderivedLatLngs[i],\n\t\t\t\t\tderivedBearings[i] - yawn / 2,\n\t\t\t\t\tsize\n\t\t\t\t);\n\n\t\t\t\tlet rightWingPoint = L.GeometryUtil.destination(\n\t\t\t\t\tderivedLatLngs[i],\n\t\t\t\t\tderivedBearings[i] + yawn / 2,\n\t\t\t\t\tsize\n\t\t\t\t);\n\n\t\t\t\tlet hatPoints = [\n\t\t\t\t\t[leftWingPoint.lat, leftWingPoint.lng],\n\t\t\t\t\t[derivedLatLngs[i].lat, derivedLatLngs[i].lng],\n\t\t\t\t\t[rightWingPoint.lat, rightWingPoint.lng],\n\t\t\t\t];\n\n\t\t\t\tlet hat = options.fill\n\t\t\t\t\t? L.polygon(hatPoints, { ...hatOptions, ...localHatOptions })\n\t\t\t\t\t: L.polyline(hatPoints, { ...hatOptions, ...localHatOptions });\n\n\t\t\t\thats.push(hat);\n\t\t\t}; // pushHats()\n\n\t\t\t// Function to build hats based on pixel input\n\t\t\tconst pushHatsFromPixels = (size, localHatOptions = {}) => {\n\t\t\t\tlet sizePixels = size.slice(0, size.length - 2);\n\t\t\t\tlet yawn = localHatOptions.yawn ?? options.yawn;\n\n\t\t\t\tlet derivedXY = this._map.latLngToLayerPoint(derivedLatLngs[i]);\n\n\t\t\t\tlet bearing = derivedBearings[i];\n\n\t\t\t\tlet thetaLeft = (180 - bearing - yawn / 2) * (Math.PI / 180),\n\t\t\t\t\tthetaRight = (180 - bearing + yawn / 2) * (Math.PI / 180);\n\n\t\t\t\tlet dxLeft = sizePixels * Math.sin(thetaLeft),\n\t\t\t\t\tdyLeft = sizePixels * Math.cos(thetaLeft),\n\t\t\t\t\tdxRight = sizePixels * Math.sin(thetaRight),\n\t\t\t\t\tdyRight = sizePixels * Math.cos(thetaRight);\n\n\t\t\t\tlet leftWingXY = {\n\t\t\t\t\tx: derivedXY.x + dxLeft,\n\t\t\t\t\ty: derivedXY.y + dyLeft,\n\t\t\t\t};\n\t\t\t\tlet rightWingXY = {\n\t\t\t\t\tx: derivedXY.x + dxRight,\n\t\t\t\t\ty: derivedXY.y + dyRight,\n\t\t\t\t};\n\n\t\t\t\tlet leftWingPoint = this._map.layerPointToLatLng(leftWingXY),\n\t\t\t\t\trightWingPoint = this._map.layerPointToLatLng(rightWingXY);\n\n\t\t\t\tlet hatPoints = [\n\t\t\t\t\t[leftWingPoint.lat, leftWingPoint.lng],\n\t\t\t\t\t[derivedLatLngs[i].lat, derivedLatLngs[i].lng],\n\t\t\t\t\t[rightWingPoint.lat, rightWingPoint.lng],\n\t\t\t\t];\n\n\t\t\t\tlet hat = options.fill\n\t\t\t\t\t? L.polygon(hatPoints, { ...hatOptions, ...localHatOptions })\n\t\t\t\t\t: L.polyline(hatPoints, { ...hatOptions, ...localHatOptions });\n\n\t\t\t\thats.push(hat);\n\t\t\t}; // pushHatsFromPixels()\n\n\t\t\t//  -------  LOOP THROUGH POINTS IN EACH SEGMENT ---------- //\n\t\t\tfor (var i = 0; i < derivedLatLngs.length; i++) {\n\t\t\t\tlet { perArrowheadOptions, ...globalOptions } = options;\n\n\t\t\t\tperArrowheadOptions = perArrowheadOptions ? perArrowheadOptions(i) : {};\n\t\t\t\tperArrowheadOptions = Object.assign(\n\t\t\t\t\tglobalOptions,\n\t\t\t\t\tdefinedProps(perArrowheadOptions)\n\t\t\t\t);\n\n\t\t\t\tsize = perArrowheadOptions.size ?? size;\n\n\t\t\t\t// ---- If size is chosen in meters -------------------------\n\t\t\t\tif (isInMeters(size)) {\n\t\t\t\t\tlet hatSize = size.slice(0, size.length - 1);\n\t\t\t\t\tpushHats(hatSize, perArrowheadOptions);\n\n\t\t\t\t\t// ---- If size is chosen in percent ------------------------\n\t\t\t\t} else if (isInPercent(size)) {\n\t\t\t\t\tlet sizePercent = size.slice(0, size.length - 1);\n\t\t\t\t\tlet hatSize = (() => {\n\t\t\t\t\t\tif (\n\t\t\t\t\t\t\toptions.frequency === 'endonly' &&\n\t\t\t\t\t\t\toptions.proportionalToTotal\n\t\t\t\t\t\t) {\n\t\t\t\t\t\t\treturn (totalLength * sizePercent) / 100;\n\t\t\t\t\t\t} else {\n\t\t\t\t\t\t\tlet averageDistance = totalLength / (peice.length - 1);\n\t\t\t\t\t\t\treturn (averageDistance * sizePercent) / 100;\n\t\t\t\t\t\t}\n\t\t\t\t\t})(); // hatsize calculation\n\n\t\t\t\t\tpushHats(hatSize, perArrowheadOptions);\n\n\t\t\t\t\t// ---- If size is chosen in pixels --------------------------\n\t\t\t\t} else if (isInPixels(size)) {\n\t\t\t\t\tpushHatsFromPixels(options.size, perArrowheadOptions);\n\n\t\t\t\t\t// ---- If size unit is not given -----------------------------\n\t\t\t\t} else {\n\t\t\t\t\tconsole.error(\n\t\t\t\t\t\t'Error: Arrowhead size unit not defined.  Check your arrowhead options.'\n\t\t\t\t\t);\n\t\t\t\t} // if else block for Size\n\t\t\t} // for loop for each point witin a peice\n\n\t\t\tallhats.push(...hats);\n\t\t}); // forEach peice\n\n\t\t//  --------- LOOP THROUGH EACH POLYLINE END ---------------- //\n\t\t//  --------------------------------------------------------- //\n\n\t\tlet arrowheads = L.layerGroup(allhats);\n\t\tthis._arrowheads = arrowheads;\n\n\t\treturn this;\n\t},\n\n\tgetArrowheads: function () {\n\t\tif (this._arrowheads) {\n\t\t\treturn this._arrowheads;\n\t\t} else {\n\t\t\treturn console.error(\n\t\t\t\t`Error: You tried to call '.getArrowheads() on a shape that does not have a arrowhead.  Use '.arrowheads()' to add a arrowheads before trying to call '.getArrowheads()'`\n\t\t\t);\n\t\t}\n\t},\n\n\t/**\n\t * Builds ghost polylines that are clipped versions of the polylines based on the offsets\n\t * If offsets are used, arrowheads are drawn from 'this._ghosts' rather than 'this'\n\t */\n\t_buildGhosts: function ({ start, end }) {\n\t\tif (start || end) {\n\t\t\tlet latlngs = this.getLatLngs();\n\n\t\t\tlatlngs = Array.isArray(latlngs[0]) ? latlngs : [latlngs];\n\n\t\t\tconst newLatLngs = latlngs.map((segment) => {\n\t\t\t\t// Get total distance of original latlngs\n\t\t\t\tconst totalLength = (() => {\n\t\t\t\t\tlet total = 0;\n\t\t\t\t\tfor (var i = 0; i < segment.length - 1; i++) {\n\t\t\t\t\t\ttotal += this._map.distance(segment[i], segment[i + 1]);\n\t\t\t\t\t}\n\t\t\t\t\treturn total;\n\t\t\t\t})();\n\n\t\t\t\t// Modify latlngs to end at interpolated point\n\t\t\t\tif (start) {\n\t\t\t\t\tlet endOffsetInMeters = (() => {\n\t\t\t\t\t\tif (isInMeters(start)) {\n\t\t\t\t\t\t\treturn Number(start.slice(0, start.length - 1));\n\t\t\t\t\t\t} else if (isInPixels(start)) {\n\t\t\t\t\t\t\tlet pixels = Number(start.slice(0, start.length - 2));\n\t\t\t\t\t\t\treturn pixelsToMeters(pixels, this._map);\n\t\t\t\t\t\t}\n\t\t\t\t\t})();\n\n\t\t\t\t\tlet newStart = L.GeometryUtil.interpolateOnLine(\n\t\t\t\t\t\tthis._map,\n\t\t\t\t\t\tsegment,\n\t\t\t\t\t\tendOffsetInMeters / totalLength\n\t\t\t\t\t);\n\n\t\t\t\t\tsegment = segment.slice(\n\t\t\t\t\t\tnewStart.predecessor === -1 ? 1 : newStart.predecessor + 1,\n\t\t\t\t\t\tsegment.length\n\t\t\t\t\t);\n\t\t\t\t\tsegment.unshift(newStart.latLng);\n\t\t\t\t}\n\n\t\t\t\tif (end) {\n\t\t\t\t\tlet endOffsetInMeters = (() => {\n\t\t\t\t\t\tif (isInMeters(end)) {\n\t\t\t\t\t\t\treturn Number(end.slice(0, end.length - 1));\n\t\t\t\t\t\t} else if (isInPixels(end)) {\n\t\t\t\t\t\t\tlet pixels = Number(end.slice(0, end.length - 2));\n\t\t\t\t\t\t\treturn pixelsToMeters(pixels, this._map);\n\t\t\t\t\t\t}\n\t\t\t\t\t})();\n\n\t\t\t\t\tlet newEnd = L.GeometryUtil.interpolateOnLine(\n\t\t\t\t\t\tthis._map,\n\t\t\t\t\t\tsegment,\n\t\t\t\t\t\t(totalLength - endOffsetInMeters) / totalLength\n\t\t\t\t\t);\n\n\t\t\t\t\tsegment = segment.slice(0, newEnd.predecessor + 1);\n\t\t\t\t\tsegment.push(newEnd.latLng);\n\t\t\t\t}\n\n\t\t\t\treturn segment;\n\t\t\t});\n\n\t\t\tthis._ghosts = L.polyline(newLatLngs, {\n\t\t\t\t...this.options,\n\t\t\t\tcolor: 'rgba(0,0,0,0)',\n\t\t\t\tstroke: 0,\n\t\t\t\tsmoothFactor: 0,\n\t\t\t\tinteractive: false,\n\t\t\t});\n\t\t\tthis._ghosts.addTo(this._map);\n\t\t}\n\t},\n\n\tdeleteArrowheads: function () {\n\t\tif (this._arrowheads) {\n\t\t\tthis._arrowheads.remove();\n\t\t\tdelete this._arrowheads;\n\t\t\tdelete this._arrowheadOptions;\n\t\t\tthis._hatsApplied = false;\n\t\t}\n\t\tif (this._ghosts) {\n\t\t\tthis._ghosts.remove();\n\t\t}\n\t},\n\n\t_update: function () {\n\t\tif (!this._map) {\n\t\t\treturn;\n\t\t}\n\n\t\tthis._clipPoints();\n\t\tthis._simplifyPoints();\n\t\tthis._updatePath();\n\n\t\tif (this._hatsApplied) {\n\t\t\tthis.buildVectorHats(this._arrowheadOptions);\n\t\t\tthis._map.addLayer(this._arrowheads);\n\t\t}\n\t},\n\n\tremove: function () {\n\t\tif (this._arrowheads) {\n\t\t\tthis._arrowheads.remove();\n\t\t}\n\t\tif (this._ghosts) {\n\t\t\tthis._ghosts.remove();\n\t\t}\n\t\treturn this.removeFrom(this._map || this._mapToAdd);\n\t},\n});\n\nL.LayerGroup.include({\n\tremoveLayer: function (layer) {\n\t\tvar id = layer in this._layers ? layer : this.getLayerId(layer);\n\n\t\tif (this._map && this._layers[id]) {\n\t\t\tif (this._layers[id]._arrowheads) {\n\t\t\t\tthis._layers[id]._arrowheads.remove();\n\t\t\t}\n\t\t\tthis._map.removeLayer(this._layers[id]);\n\t\t}\n\n\t\tdelete this._layers[id];\n\n\t\treturn this;\n\t},\n\n\tonRemove: function (map, layer) {\n\t\tfor (var layer in this._layers) {\n\t\t\tif (this._layers[layer]) {\n\t\t\t\tthis._layers[layer].remove();\n\t\t\t}\n\t\t}\n\n\t\tthis.eachLayer(map.removeLayer, map);\n\t},\n});\n\nL.Map.include({\n\tremoveLayer: function (layer) {\n\t\tvar id = L.Util.stamp(layer);\n\n\t\tif (layer._arrowheads) {\n\t\t\tlayer._arrowheads.remove();\n\t\t}\n\t\tif (layer._ghosts) {\n\t\t\tlayer._ghosts.remove();\n\t\t}\n\n\t\tif (!this._layers[id]) {\n\t\t\treturn this;\n\t\t}\n\n\t\tif (this._loaded) {\n\t\t\tlayer.onRemove(this);\n\t\t}\n\n\t\tif (layer.getAttribution && this.attributionControl) {\n\t\t\tthis.attributionControl.removeAttribution(layer.getAttribution());\n\t\t}\n\n\t\tdelete this._layers[id];\n\n\t\tif (this._loaded) {\n\t\t\tthis.fire('layerremove', { layer: layer });\n\t\t\tlayer.fire('remove');\n\t\t}\n\n\t\tlayer._map = layer._mapToAdd = null;\n\n\t\treturn this;\n\t},\n});\n\nL.GeoJSON.include({\n\tgeometryToLayer: function (geojson, options) {\n\t\tvar geometry = geojson.type === 'Feature' ? geojson.geometry : geojson,\n\t\t\tcoords = geometry ? geometry.coordinates : null,\n\t\t\tlayers = [],\n\t\t\tpointToLayer = options && options.pointToLayer,\n\t\t\t_coordsToLatLng =\n\t\t\t\t(options && options.coordsToLatLng) || L.GeoJSON.coordsToLatLng,\n\t\t\tlatlng,\n\t\t\tlatlngs,\n\t\t\ti,\n\t\t\tlen;\n\n\t\tif (!coords && !geometry) {\n\t\t\treturn null;\n\t\t}\n\n\t\tswitch (geometry.type) {\n\t\t\tcase 'Point':\n\t\t\t\tlatlng = _coordsToLatLng(coords);\n\t\t\t\treturn this._pointToLayer(pointToLayer, geojson, latlng, options);\n\n\t\t\tcase 'MultiPoint':\n\t\t\t\tfor (i = 0, len = coords.length; i < len; i++) {\n\t\t\t\t\tlatlng = _coordsToLatLng(coords[i]);\n\t\t\t\t\tlayers.push(\n\t\t\t\t\t\tthis._pointToLayer(pointToLayer, geojson, latlng, options)\n\t\t\t\t\t);\n\t\t\t\t}\n\t\t\t\treturn new L.FeatureGroup(layers);\n\n\t\t\tcase 'LineString':\n\t\t\tcase 'MultiLineString':\n\t\t\t\tlatlngs = L.GeoJSON.coordsToLatLngs(\n\t\t\t\t\tcoords,\n\t\t\t\t\tgeometry.type === 'LineString' ? 0 : 1,\n\t\t\t\t\t_coordsToLatLng\n\t\t\t\t);\n\t\t\t\tvar polyline = new L.Polyline(latlngs, options);\n\t\t\t\tif (options.arrowheads) {\n\t\t\t\t\tpolyline.arrowheads(options.arrowheads);\n\t\t\t\t}\n\t\t\t\treturn polyline;\n\n\t\t\tcase 'Polygon':\n\t\t\tcase 'MultiPolygon':\n\t\t\t\tlatlngs = L.GeoJSON.coordsToLatLngs(\n\t\t\t\t\tcoords,\n\t\t\t\t\tgeometry.type === 'Polygon' ? 1 : 2,\n\t\t\t\t\t_coordsToLatLng\n\t\t\t\t);\n\t\t\t\treturn new L.Polygon(latlngs, options);\n\n\t\t\tcase 'GeometryCollection':\n\t\t\t\tfor (i = 0, len = geometry.geometries.length; i < len; i++) {\n\t\t\t\t\tvar layer = this.geometryToLayer(\n\t\t\t\t\t\t{\n\t\t\t\t\t\t\tgeometry: geometry.geometries[i],\n\t\t\t\t\t\t\ttype: 'Feature',\n\t\t\t\t\t\t\tproperties: geojson.properties,\n\t\t\t\t\t\t},\n\t\t\t\t\t\toptions\n\t\t\t\t\t);\n\n\t\t\t\t\tif (layer) {\n\t\t\t\t\t\tlayers.push(layer);\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\treturn new L.FeatureGroup(layers);\n\n\t\t\tdefault:\n\t\t\t\tthrow new Error('Invalid GeoJSON object.');\n\t\t}\n\t},\n\n\taddData: function (geojson) {\n\t\tvar features = L.Util.isArray(geojson) ? geojson : geojson.features,\n\t\t\ti,\n\t\t\tlen,\n\t\t\tfeature;\n\n\t\tif (features) {\n\t\t\tfor (i = 0, len = features.length; i < len; i++) {\n\t\t\t\t// only add this if geometry or geometries are set and not null\n\t\t\t\tfeature = features[i];\n\t\t\t\tif (\n\t\t\t\t\tfeature.geometries ||\n\t\t\t\t\tfeature.geometry ||\n\t\t\t\t\tfeature.features ||\n\t\t\t\t\tfeature.coordinates\n\t\t\t\t) {\n\t\t\t\t\tthis.addData(feature);\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn this;\n\t\t}\n\n\t\tvar options = this.options;\n\n\t\tif (options.filter && !options.filter(geojson)) {\n\t\t\treturn this;\n\t\t}\n\n\t\tvar layer = this.geometryToLayer(geojson, options);\n\t\tif (!layer) {\n\t\t\treturn this;\n\t\t}\n\t\tlayer.feature = L.GeoJSON.asFeature(geojson);\n\n\t\tlayer.defaultOptions = layer.options;\n\t\tthis.resetStyle(layer);\n\n\t\tif (options.onEachFeature) {\n\t\t\toptions.onEachFeature(geojson, layer);\n\t\t}\n\n\t\treturn this.addLayer(layer);\n\t},\n\n\t_pointToLayer: function (pointToLayerFn, geojson, latlng, options) {\n\t\treturn pointToLayerFn\n\t\t\t? pointToLayerFn(geojson, latlng)\n\t\t\t: new L.Marker(\n\t\t\t\t\tlatlng,\n\t\t\t\t\toptions && options.markersInheritOptions && options\n\t\t\t  );\n\t},\n});\n"],
  "mappings": "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",
  "names": ["L", "latlngs", "i", "i", "size"]
}
